# Task ID: 3
# Title: Extract ConnectivityManager from ConnectivityObserver
# Status: done
# Dependencies: 1
# Priority: high
# Description: Create non-reactive ConnectivityManager class in SundialKitConnectivity target for WatchConnectivity management
# Details:
Extract and refactor ConnectivityManager from existing ConnectivityObserver (Sources/SundialKit/WatchConnectivity/ConnectivityObserver.swift):
1. Move core WatchConnectivity logic from ConnectivityObserver to new ConnectivityManager
2. Remove all Combine dependencies (Published, PassthroughSubject, AnyCancellable from lines 46)
3. Implement ConnectivityManagement protocol from SundialKitCore
4. Maintain ConnectivitySession protocol abstraction from Sources/SundialKit/WatchConnectivity/ConnectivitySession.swift
5. Reuse existing WatchConnectivitySession implementation (Sources/SundialKit/WatchConnectivity/WatchConnectivitySession.swift)
6. Handle platform-specific delegate methods from ConnectivitySessionDelegate:
   - sessionDidBecomeInactive (iOS only, lines 126-128)
   - sessionDidDeactivate (iOS only, lines 130-132)
   - sessionWatchStateDidChange (iOS only, mapped to sessionCompanionStateDidChange)
7. Bridge delegate-based activation to async/await using continuations
8. Implement activation timeout handling
9. Extract message routing logic from sendMessage method (lines 163-182):
   - sendMessage when reachable
   - updateApplicationContext fallback when paired app installed
   - throw ConnectivityError when companion unavailable
10. Observer pattern for state changes using ConnectivityStateObserver protocol
11. Platform guards for iOS/watchOS only (existing #if os patterns)
12. Reuse MockSession for testing (Tests/SundialKitTests/MockSession.swift)

Key implementation details from existing code:
- Thread-safe delegate handling using DispatchQueue.main.async (lines 135, 146)
- Error mapping from SundialError.missingCompanion to ConnectivityError
- Message size validation (65KB WatchConnectivity limit)
- Session lifecycle management with proper delegate assignment

GitHub Issue: #31, Component: WatchConnectivity

# Test Strategy:
Swift Testing required. Port existing test patterns from Tests/SundialKitTests/WatchConnectivity/. Test activation lifecycle, message sending/receiving using MockSession patterns from ConnectivityObserverMessageTests.swift, reachability changes, platform-specific behavior (iOS vs watchOS), timeout scenarios, and fallback mechanisms using existing ConnectivityObserverPropertyTests.swift structure.

# Subtasks:
## 1. Create ConnectivityManager class implementing ConnectivityManagement protocol [done]
### Dependencies: None
### Description: Create the main ConnectivityManager class in SundialKitConnectivity target that implements the ConnectivityManagement protocol from SundialKitCore, establishing the foundational structure for WatchConnectivity management
### Details:
Create ConnectivityManager.swift in SundialKitConnectivity/Sources with class definition implementing ConnectivityManagement protocol. Structure similar to existing ConnectivityObserver (Sources/SundialKit/WatchConnectivity/ConnectivityObserver.swift) but without Combine dependencies. Include properties for session management (internal let session: ConnectivitySession), state tracking (activationState, isReachable, isPaired, isPairedAppInstalled), observer storage using weak references, and delegate handling. Implement basic initializer with ConnectivitySession parameter and convenience initializer. Add platform availability guards matching existing @available(macOS, unavailable) @available(tvOS, unavailable) patterns. Remove all PassthroughSubject and AnyCancellable references.

## 2. Reuse existing ConnectivitySession abstraction and WatchConnectivitySession implementation [done]
### Dependencies: 3.1
### Description: Leverage the existing ConnectivitySession protocol (Sources/SundialKit/WatchConnectivity/ConnectivitySession.swift) and WatchConnectivitySession implementation for the abstraction layer
### Details:
Reuse existing ConnectivitySession protocol from Sources/SundialKit/WatchConnectivity/ConnectivitySession.swift with methods for activation, message sending, application context updates, and state queries. Leverage existing WatchConnectivitySession wrapper from Sources/SundialKit/WatchConnectivity/WatchConnectivitySession.swift around WCSession with all delegate methods implemented. The abstraction already includes platform-specific properties (#if os(iOS) var isPaired), thread-safe delegate assignment, and proper session lifecycle management. Continue using MockSession from Tests/SundialKitTests/MockSession.swift for testing purposes. No changes needed to these existing abstractions.

## 3. Implement ConnectivitySessionDelegate methods with platform-specific handling [done]
### Dependencies: 3.2
### Description: Implement ConnectivitySessionDelegate protocol methods in ConnectivityManager, handling platform-specific delegate callbacks from existing WatchConnectivitySession
### Details:
Implement ConnectivitySessionDelegate conformance on ConnectivityManager using existing patterns from ConnectivityObserver (lines 126-199). Port methods: session(_:activationDidCompleteWith:error:) with main queue dispatch (lines 141-155), sessionDidBecomeInactive (lines 126-128), sessionDidDeactivate (lines 130-132), sessionCompanionStateDidChange (lines 134-139), sessionReachabilityDidChange (lines 157-161), session(_:didReceiveMessage:replyHandler:) (lines 184-190), session(_:didReceiveApplicationContext:error:) (lines 192-199). Update internal state properties based on delegate callbacks. Use existing DispatchQueue.main.async patterns for thread-safe state updates (lines 135, 146).

## 4. Bridge delegate-based activation to async/await with continuations and timeout [done]
### Dependencies: 3.3
### Description: Convert the synchronous activation pattern to modern async/await using continuations, including timeout handling for activation failures
### Details:
Implement async activate() method using withCheckedThrowingContinuation to bridge delegate callbacks from session(_:activationDidCompleteWith:error:). Store continuation as optional property and resume on delegate callback. Add configurable timeout (default 30 seconds) using Task.sleep and cancellation. Handle race conditions between timeout and successful activation. Map activation errors and SundialError.sessionNotSupported to ConnectivityError cases. Ensure continuation is only resumed once to prevent crashes. Clean up stored continuation on completion or timeout. Follow existing session.activate() patterns from ConnectivityObserver.activate() (lines 121-124).

## 5. Extract and adapt message routing logic from ConnectivityObserver [done]
### Dependencies: 3.4
### Description: Port the intelligent message routing logic from ConnectivityObserver.sendMessage method that uses sendMessage when reachable and falls back to updateApplicationContext
### Details:
Port message routing logic from ConnectivityObserver.sendMessage method (lines 163-182). Implement async send(message:replyTimeout:) method that replicates existing routing logic: when session.isReachable (line 164) use session.sendMessage with completion handler (lines 165-167), when not reachable but session.isPairedAppInstalled (line 168) fallback to session.updateApplicationContext (lines 169-176), when companion unavailable throw SundialError.missingCompanion (lines 178-181). Validate message size against 65KB WatchConnectivity limit before sending. Handle reply timeouts using Task-based timing. Map existing SundialError cases to ConnectivityError from SundialKitCore.

## 6. Implement observer pattern for state change notifications [done]
### Dependencies: 3.5
### Description: Create an observer pattern system using weak references to notify interested parties about connectivity state changes without using Combine
### Details:
Define ConnectivityStateObserver protocol with methods for state change notifications: connectivityStateDidChange, reachabilityDidChange, activationStateDidChange matching the state changes from existing Subject patterns (activationStateSubject line 48, isReachableSubject line 49, isPairedAppInstalledSubject line 50, isPairedSubject line 51). Implement observer management with weak reference array using NSHashTable or similar to prevent retain cycles. Create thread-safe add/remove observer methods using appropriate locking mechanism. Notify observers on main queue when state changes occur from delegate callbacks, replacing the Subject.send calls. Provide granular notification methods for different state aspects. Include automatic cleanup of deallocated observers.

## 7. Handle error mapping from SundialError to ConnectivityError [done]
### Dependencies: 3.6
### Description: Create comprehensive error mapping system that converts existing SundialError cases and WatchConnectivity framework errors to domain-specific ConnectivityError cases
### Details:
Implement error mapping to convert existing SundialError cases (sessionNotSupported, missingCompanion from Sources/SundialKit/SundialError.swift) to ConnectivityError enum cases defined in SundialKitCore. Map WCError codes to granular ConnectivityError cases: notReachable, deviceNotPaired, watchAppNotInstalled, notActivated, fileAccessDenied, deliveryFailed, insufficientSpace, sessionMissingDelegate, sessionNotActivated, sessionNotSupported, badPayload, messageReplyFailed, messageReplyTimedOut, transferTimedOut. Preserve original error as underlying error for debugging. Create helper methods for common error scenarios. Include descriptive error messages for each case following LocalizedError protocol patterns.

## 8. Create comprehensive platform-specific tests using existing test patterns [done]
### Dependencies: 3.7
### Description: Develop a complete test suite using Swift Testing that covers all ConnectivityManager functionality, leveraging existing test patterns and MockSession
### Details:
Create ConnectivityManagerTests using Swift Testing framework with platform-conditional compilation following existing test patterns. Port test structure from ConnectivityObserverMessageTests.swift and ConnectivityObserverPropertyTests.swift. Test activation lifecycle including success, failure, and timeout scenarios. Verify message sending and receiving with MockSession (reuse existing patterns from testCombineSendMessageReachable and testCombineSendMessageAppInstalled). Test reachability state changes and observer notifications. Validate platform-specific delegate methods on iOS. Test error handling and mapping for all error cases. Verify thread safety with concurrent operations. Test message size validation and routing decisions. Include integration tests with MockSession. Ensure 90%+ code coverage matching existing test coverage.


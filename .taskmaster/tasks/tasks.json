{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create SundialKitCore protocols and types",
        "description": "Define core protocols (NetworkMonitoring, ConnectivityManagement) and value types with Sendable conformance for plugin system",
        "details": "Create SundialKitCore target with protocol definitions:\n1. NetworkMonitoring protocol with state queries (pathStatus, isExpensive, isConstrained) and lifecycle methods\n2. ConnectivityManagement protocol with state queries and messaging methods\n3. Core value types: PathStatus enum (with Interface OptionSet and UnsatisfiedReason), ActivationState enum\n4. Typed error enums: NetworkError, ConnectivityError (with granular WCError mapping), SerializationError\n5. Mark ALL types as Sendable for Swift 6.1 compatibility (CRITICAL)\n6. NetworkStateObserver and ConnectivityStateObserver protocols for callback-based notifications\n7. Helper method ConnectivityError.init(wcError:) for WCError mapping\n\nImplementation approach:\n- Use Swift 5.9+ for backwards compatibility\n- Foundation-only dependencies\n- Comprehensive documentation for plugin developers\n- Platform support: iOS 13+, watchOS 6+, tvOS 13+, macOS 10.13+",
        "testStrategy": "Swift Testing migration required. Test protocol conformance, Sendable conformance verification, error mapping accuracy, and type safety. Create mock implementations to verify protocol contracts.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define NetworkMonitoring protocol with lifecycle methods",
            "description": "Create the NetworkMonitoring protocol in SundialKitCore with all required state query properties and lifecycle methods for network monitoring plugins",
            "dependencies": [],
            "details": "Define NetworkMonitoring protocol with: pathStatus property returning PathStatus enum, isExpensive property for cost tracking, isConstrained property for low data mode, start(queue:) method for beginning monitoring, stop() method for cleanup, and proper async/throws annotations where appropriate. Include comprehensive documentation for plugin developers.",
            "status": "pending",
            "testStrategy": "Create mock implementations to verify protocol requirements, test that conforming types properly expose all required properties and methods"
          },
          {
            "id": 2,
            "title": "Define ConnectivityManagement protocol with messaging interfaces",
            "description": "Create the ConnectivityManagement protocol with all state queries and messaging methods required for WatchConnectivity plugin implementations",
            "dependencies": [],
            "details": "Define ConnectivityManagement protocol with: activationState property, isReachable property, isPaired property (iOS only with availability annotations), isPairedAppInstalled property (iOS only), sendMessage methods with async/throws, updateApplicationContext method, activate() lifecycle method. Include platform availability annotations and comprehensive documentation.",
            "status": "pending",
            "testStrategy": "Test protocol conformance with mock implementations, verify platform-specific property availability, test messaging method signatures"
          },
          {
            "id": 3,
            "title": "Create PathStatus enum with Interface and UnsatisfiedReason types",
            "description": "Implement PathStatus enum with nested Interface OptionSet and UnsatisfiedReason enum for comprehensive network state representation",
            "dependencies": [],
            "details": "Create PathStatus enum with cases: satisfied(Interface), unsatisfied(UnsatisfiedReason), requiresConnection, unknown. Define Interface as OptionSet with options: cellular, wifi, wiredEthernet, loopback, other. Define UnsatisfiedReason enum with cases: notAvailable, cellularDenied, wifiDenied, localNetworkDenied. Ensure all types conform to Sendable, Equatable, and Hashable.",
            "status": "pending",
            "testStrategy": "Test all enum cases and OptionSet combinations, verify Sendable conformance, test equatable and hashable implementations"
          },
          {
            "id": 4,
            "title": "Implement error enums with WCError mapping helpers",
            "description": "Create NetworkError, ConnectivityError, and SerializationError enums with comprehensive error cases and WCError mapping functionality",
            "dependencies": [],
            "details": "Define NetworkError enum with cases for network-specific failures. Create ConnectivityError enum with granular WCError mapping including: sessionNotActivated, watchAppNotInstalled, notReachable, messageReplyFailed, etc. Add helper initializer ConnectivityError.init(wcError:) for automatic WCError translation. Define SerializationError for encoding/decoding failures. All must conform to Error, Sendable, and LocalizedError.",
            "status": "pending",
            "testStrategy": "Test all error cases, verify WCError mapping accuracy, test localized descriptions, ensure Sendable conformance"
          },
          {
            "id": 5,
            "title": "Add Sendable conformance and comprehensive documentation",
            "description": "Ensure all types conform to Sendable for Swift 6.1 compatibility and add complete DocC documentation for the entire SundialKitCore module",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Apply Sendable conformance to all protocols, enums, and types in SundialKitCore. Add @unchecked Sendable where necessary with safety documentation. Create comprehensive DocC comments for all public APIs including usage examples, platform availability notes, and migration guidance. Add module-level documentation explaining the plugin architecture and how to implement custom plugins.",
            "status": "pending",
            "testStrategy": "Compile with Swift 6.1 strict concurrency checking enabled, verify no Sendable warnings, validate DocC builds without warnings"
          }
        ]
      },
      {
        "id": 2,
        "title": "Extract NetworkMonitor from NetworkObserver",
        "description": "Create non-reactive NetworkMonitor class in SundialKitNetwork target by extracting core logic from v1.0.0 NetworkObserver",
        "details": "Extract and refactor NetworkMonitor:\n1. Move core network monitoring logic from NetworkObserver to new NetworkMonitor class\n2. Remove all Combine dependencies (Published, PassthroughSubject, etc.)\n3. Implement NetworkMonitoring protocol from SundialKitCore\n4. Maintain PathMonitor protocol abstraction over NWPathMonitor\n5. Support optional NetworkPing integration for connectivity verification\n6. Implement observer pattern using NetworkStateObserver protocol\n7. Use weak references array for observers to prevent retain cycles\n8. Expose state through protocol methods: pathStatus, isExpensive, isConstrained\n9. Platform-specific NWPathMonitor implementation with proper queue handling\n\nKey refactoring:\n- Replace @Published with stored properties\n- Replace Combine publishers with observer callbacks\n- Maintain thread-safe state updates\n- Swift 5.9+ compatibility",
        "testStrategy": "Swift Testing required. Test state changes, observer notifications, PathMonitor mock implementations, NetworkPing integration, thread safety with concurrent observers, and platform-specific behavior.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NetworkMonitor class structure implementing NetworkMonitoring protocol",
            "description": "Create the foundational NetworkMonitor class in SundialKitNetwork target with proper imports, class declaration, and NetworkMonitoring protocol conformance",
            "dependencies": [],
            "details": "Create Sources/SundialKitNetwork/NetworkMonitor.swift file. Import Foundation and Network frameworks. Declare public class NetworkMonitor implementing NetworkMonitoring protocol from SundialKitCore. Add private properties for pathMonitor (PathMonitor protocol), networkPing (optional NetworkPing), observerQueue (DispatchQueue), and state storage properties (currentPathStatus, currentIsExpensive, currentIsConstrained). Include thread-safe observer array property using NSLock for synchronization. Add initializer accepting optional PathMonitor and NetworkPing instances.",
            "status": "pending",
            "testStrategy": "Test class initialization with mock PathMonitor and NetworkPing. Verify protocol conformance. Test property initialization and default values."
          },
          {
            "id": 2,
            "title": "Extract PathMonitor abstraction and NWPathMonitor implementation from existing code",
            "description": "Move PathMonitor protocol and DefaultPathMonitor implementation from NetworkObserver to separate files in SundialKitNetwork",
            "dependencies": [
              1
            ],
            "details": "Extract PathMonitor protocol from existing NetworkObserver code into Sources/SundialKitNetwork/PathMonitor.swift. Move DefaultPathMonitor class wrapping NWPathMonitor to same file or separate implementation file. Ensure protocol defines start(queue:), cancel(), currentPath property, and pathUpdateHandler closure. Adapt existing NWPathMonitor wrapper code removing any Combine-specific logic. Maintain platform availability checks and proper queue handling. Update NetworkMonitor to use extracted PathMonitor abstraction.",
            "status": "pending",
            "testStrategy": "Test PathMonitor protocol with mock implementations. Verify DefaultPathMonitor correctly wraps NWPathMonitor. Test queue handling and path update callbacks."
          },
          {
            "id": 3,
            "title": "Implement observer pattern with weak references and thread-safe state management",
            "description": "Implement NetworkStateObserver protocol and weak reference array for managing multiple observers with thread safety",
            "dependencies": [
              1,
              2
            ],
            "details": "Define NetworkStateObserver protocol in SundialKitCore with methods: networkStateDidChange(pathStatus:isExpensive:isConstrained:). Create WeakObserver wrapper class to hold weak references preventing retain cycles. Implement thread-safe observer management using NSLock: addObserver(), removeObserver(), and private notifyObservers() methods. Ensure all state updates acquire lock before modification. Implement cleanup mechanism to remove deallocated observers. Add observer notification logic to PathMonitor update handler ensuring observers are called on main queue or specified queue.",
            "status": "pending",
            "testStrategy": "Test concurrent observer addition/removal. Verify weak references don't create retain cycles. Test observer notifications on state changes. Validate thread safety with multiple concurrent operations."
          },
          {
            "id": 4,
            "title": "Extract and adapt NetworkPing integration logic",
            "description": "Move NetworkPing functionality from NetworkObserver to NetworkMonitor, removing Combine dependencies",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Extract NetworkPing protocol and DefaultNetworkPing implementation from existing code. Remove PassthroughSubject and replace with direct callback pattern or observer notification. Implement ping scheduling logic using Timer or DispatchQueue instead of Combine operators. Add pingStatus property to NetworkMonitor state. Integrate ping results into observer notifications. Handle ping failures and timeout scenarios. Ensure optional ping support - NetworkMonitor should function without NetworkPing instance. Maintain existing ping interval and timeout configurations.",
            "status": "pending",
            "testStrategy": "Test NetworkMonitor with and without NetworkPing. Verify ping scheduling and result handling. Test timeout scenarios and failure cases. Mock NetworkPing for controlled testing."
          },
          {
            "id": 5,
            "title": "Remove Combine dependencies and replace with stored properties",
            "description": "Refactor all Combine-specific code replacing @Published properties and PassthroughSubjects with regular stored properties",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Remove all Combine imports from NetworkMonitor. Replace @Published var pathStatus with private(set) var currentPathStatus: PathStatus. Replace @Published var isExpensive with private(set) var currentIsExpensive: Bool. Replace @Published var isConstrained with private(set) var currentIsConstrained: Bool. Remove any PassthroughSubject usage for internal events. Ensure state updates trigger observer notifications instead of publisher events. Update all internal state management to use direct property assignment with proper thread synchronization. Maintain state consistency during updates.",
            "status": "pending",
            "testStrategy": "Verify no Combine imports remain. Test state updates trigger observer notifications. Validate property access thread safety. Test state consistency during rapid updates."
          },
          {
            "id": 6,
            "title": "Implement state query methods and lifecycle management",
            "description": "Implement NetworkMonitoring protocol methods for state queries and complete lifecycle management including start/stop functionality",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implement pathStatus() -> PathStatus method returning current path status. Implement isExpensive() -> Bool and isConstrained() -> Bool query methods. Add start(queue: DispatchQueue?) method initializing PathMonitor and optional NetworkPing with proper queue setup. Implement stop() method cancelling PathMonitor, stopping NetworkPing, and clearing observers. Add isMonitoring property tracking active state. Ensure proper cleanup in deinit. Handle edge cases like multiple start/stop calls. Implement any additional NetworkMonitoring protocol requirements from SundialKitCore.",
            "status": "pending",
            "testStrategy": "Test start/stop lifecycle with various scenarios. Verify state query methods return correct values. Test cleanup on deinit. Validate behavior with multiple start/stop calls."
          },
          {
            "id": 7,
            "title": "Create comprehensive unit tests with mocks",
            "description": "Develop complete test suite using Swift Testing framework with mock implementations for all dependencies",
            "dependencies": [
              6
            ],
            "details": "Create Tests/SundialKitNetworkTests/NetworkMonitorTests.swift using Swift Testing framework. Implement MockPathMonitor conforming to PathMonitor protocol with controllable behavior. Create MockNetworkPing for testing ping integration. Write tests for: initialization with various configurations, observer registration and notification, state transitions and updates, thread safety with concurrent operations, PathMonitor integration, NetworkPing optional behavior, lifecycle management (start/stop/deinit), error handling and edge cases. Ensure minimum 80% code coverage. Test platform-specific behavior where applicable.",
            "status": "pending",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 3,
        "title": "Extract ConnectivityManager from ConnectivityObserver",
        "description": "Create non-reactive ConnectivityManager class in SundialKitConnectivity target for WatchConnectivity management",
        "details": "Extract and refactor ConnectivityManager:\n1. Move core WatchConnectivity logic from ConnectivityObserver to new ConnectivityManager\n2. Remove all Combine dependencies (Published, PassthroughSubject)\n3. Implement ConnectivityManagement protocol from SundialKitCore\n4. Maintain ConnectivitySession protocol abstraction over WCSession\n5. Handle platform-specific delegate methods:\n   - sessionDidBecomeInactive (iOS only)\n   - sessionDidDeactivate (iOS only)\n   - sessionWatchStateDidChange (iOS only)\n6. Bridge delegate-based activation to async/await using continuations\n7. Implement activation timeout handling\n8. Message routing logic: sendMessage when reachable, updateApplicationContext fallback\n9. Observer pattern for state changes\n10. Platform guards for iOS/watchOS only\n\nKey considerations:\n- Thread-safe delegate handling\n- Proper error mapping to ConnectivityError\n- Message size validation (65KB limit)",
        "testStrategy": "Swift Testing required. Test activation lifecycle, message sending/receiving, reachability changes, platform-specific behavior (iOS vs watchOS), timeout scenarios, and fallback mechanisms.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ConnectivityManager class implementing ConnectivityManagement protocol",
            "description": "Create the main ConnectivityManager class in SundialKitConnectivity target that implements the ConnectivityManagement protocol from SundialKitCore, establishing the foundational structure for WatchConnectivity management",
            "dependencies": [],
            "details": "Create ConnectivityManager.swift in SundialKitConnectivity/Sources with class definition implementing ConnectivityManagement protocol. Include properties for session management, state tracking (activationState, isReachable, isPaired, isPairedAppInstalled), observer storage using weak references, and delegate handling. Implement basic initializer and deinitializer. Add platform availability guards for iOS and watchOS only. Structure should mirror existing ConnectivityObserver but without any Combine dependencies.",
            "status": "pending",
            "testStrategy": "Test class initialization, protocol conformance, property initialization, and platform availability on iOS and watchOS simulators"
          },
          {
            "id": 2,
            "title": "Extract ConnectivitySession abstraction over WCSession from existing code",
            "description": "Port the ConnectivitySession protocol and its WCSession implementation from the existing codebase, maintaining the abstraction layer for testability",
            "dependencies": [
              1
            ],
            "details": "Extract ConnectivitySession protocol from existing ConnectivityObserver implementation. Create DefaultConnectivitySession wrapper around WCSession with all necessary delegate methods. Maintain protocol methods for activation, message sending, application context updates, and state queries. Ensure thread-safe delegate assignment and proper session lifecycle management. Include MockConnectivitySession for testing purposes. Preserve the abstraction that allows swapping implementations.",
            "status": "pending",
            "testStrategy": "Test protocol implementation, delegate callbacks, mock session behavior, and verify abstraction maintains same interface as v1"
          },
          {
            "id": 3,
            "title": "Implement platform-specific delegate methods with iOS/watchOS guards",
            "description": "Implement all WCSessionDelegate methods with proper platform availability checks, handling iOS-only methods like sessionDidBecomeInactive and sessionDidDeactivate",
            "dependencies": [
              2
            ],
            "details": "Implement WCSessionDelegate extension on ConnectivityManager with all required and optional methods. Add #available and platform checks for iOS-only methods: sessionDidBecomeInactive, sessionDidDeactivate, sessionWatchStateDidChange. Implement shared methods: session(_:activationDidCompleteWith:error:), session(_:didReceiveMessage:), session(_:didReceiveMessage:replyHandler:), session(_:didReceiveApplicationContext:). Update internal state properties based on delegate callbacks. Ensure thread-safe state updates using appropriate synchronization.",
            "status": "pending",
            "testStrategy": "Test each delegate method with mock sessions, verify platform-specific methods only called on iOS, test state updates from callbacks"
          },
          {
            "id": 4,
            "title": "Bridge delegate-based activation to async/await with continuations and timeout",
            "description": "Convert the delegate-based WCSession activation pattern to modern async/await using continuations, including timeout handling for activation failures",
            "dependencies": [
              3
            ],
            "details": "Implement async activate() method using withCheckedThrowingContinuation to bridge delegate callbacks. Store continuation and resume on session(_:activationDidCompleteWith:error:) callback. Add configurable timeout (default 30 seconds) using Task.sleep and cancellation. Handle race conditions between timeout and successful activation. Map activation errors to ConnectivityError cases. Ensure continuation is only resumed once to prevent crashes. Clean up stored continuation on completion or timeout.",
            "status": "pending",
            "testStrategy": "Test successful activation, timeout scenarios, error handling, concurrent activation attempts, and continuation cleanup"
          },
          {
            "id": 5,
            "title": "Extract message routing logic with sendMessage and updateApplicationContext fallback",
            "description": "Implement intelligent message routing that uses sendMessage when reachable and falls back to updateApplicationContext when the companion app is installed but not reachable",
            "dependencies": [
              4
            ],
            "details": "Port message routing logic from ConnectivityObserver. Implement async send(message:replyTimeout:) method that checks reachability and routes appropriately. When reachable: use session.sendMessage with optional reply handler. When not reachable but paired app installed: fallback to updateApplicationContext. When companion unavailable: throw appropriate ConnectivityError. Validate message size against 65KB limit before sending. Handle reply timeouts using Task-based timing. Implement proper error mapping from WCError to ConnectivityError.",
            "status": "pending",
            "testStrategy": "Test message routing decisions, fallback behavior, size validation, timeout handling, and error scenarios"
          },
          {
            "id": 6,
            "title": "Implement observer pattern for state change notifications",
            "description": "Create an observer pattern system using weak references to notify interested parties about connectivity state changes without using Combine",
            "dependencies": [
              5
            ],
            "details": "Define ConnectivityStateObserver protocol with methods for state change notifications: connectivityStateDidChange, reachabilityDidChange, activationStateDidChange, etc. Implement observer management with weak reference array to prevent retain cycles. Create thread-safe add/remove observer methods using appropriate locking mechanism. Notify observers on main queue when state changes occur from delegate callbacks. Provide granular notification methods for different state aspects. Include automatic cleanup of deallocated observers.",
            "status": "pending",
            "testStrategy": "Test observer registration/removal, weak reference behavior, notification delivery, thread safety with concurrent observers"
          },
          {
            "id": 7,
            "title": "Handle error mapping from WCError to ConnectivityError",
            "description": "Create comprehensive error mapping system that converts WatchConnectivity framework errors to domain-specific ConnectivityError cases",
            "dependencies": [
              6
            ],
            "details": "Implement error mapping extension to convert WCError to ConnectivityError enum cases defined in SundialKitCore. Map specific WCError codes: notReachable, deviceNotPaired, watchAppNotInstalled, notActivated, fileAccessDenied, deliveryFailed, insufficientSpace, sessionMissingDelegate, sessionNotActivated, sessionNotSupported, badPayload, messageReplyFailed, messageReplyTimedOut, transferTimedOut. Preserve original error as underlying error for debugging. Create helper methods for common error scenarios. Include descriptive error messages for each case.",
            "status": "pending",
            "testStrategy": "Test all WCError to ConnectivityError mappings, verify error messages, test error propagation through async methods"
          },
          {
            "id": 8,
            "title": "Create comprehensive platform-specific tests",
            "description": "Develop a complete test suite using Swift Testing that covers all ConnectivityManager functionality with platform-specific test cases for iOS and watchOS",
            "dependencies": [
              7
            ],
            "details": "Create ConnectivityManagerTests using Swift Testing framework with platform-conditional compilation. Test activation lifecycle including success, failure, and timeout scenarios. Verify message sending and receiving with mock sessions. Test reachability state changes and observer notifications. Validate platform-specific delegate methods on iOS. Test error handling and mapping for all error cases. Verify thread safety with concurrent operations. Test message size validation and routing decisions. Include integration tests with MockConnectivitySession. Ensure 90%+ code coverage.",
            "status": "pending",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 4,
        "title": "Create SundialKit umbrella target",
        "description": "Configure umbrella target that re-exports SundialKitCore, SundialKitNetwork, and SundialKitConnectivity for convenience",
        "details": "Create SundialKit umbrella target:\n1. Update Package.swift to define SundialKit product\n2. Create SundialKit.swift with @_exported imports:\n   - @_exported import SundialKitCore\n   - @_exported import SundialKitNetwork  \n   - @_exported import SundialKitConnectivity\n3. Configure platform restrictions (iOS 13+, watchOS 6+ - most restrictive)\n4. No additional code - pure re-export target\n5. Update documentation to explain import options:\n   - Individual imports for selective features\n   - SundialKit import for everything\n6. Verify all public APIs are accessible through umbrella import\n\nPackage.swift configuration:\n- Product definition with all three targets\n- Proper dependency declarations\n- Platform version specifications",
        "testStrategy": "Swift Testing required. Verify all public APIs accessible through umbrella import, test compilation on all supported platforms, validate no symbol conflicts.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Package.swift to define SundialKit umbrella product",
            "description": "Modify Package.swift to add the SundialKit product that combines all three module targets with proper dependency declarations and platform restrictions",
            "dependencies": [],
            "details": "Edit Package.swift to add a new product named 'SundialKit' that includes SundialKitCore, SundialKitNetwork, and SundialKitConnectivity as targets. Set platform requirements to iOS 13.0+ and watchOS 6.0+ (the most restrictive of all modules). Ensure the product properly declares its target dependencies and that the SundialKit target itself depends on all three module targets.",
            "status": "pending",
            "testStrategy": "Verify Package.swift compiles without errors using 'swift build' and that the SundialKit product appears in the package manifest"
          },
          {
            "id": 2,
            "title": "Create SundialKit.swift with @_exported module imports",
            "description": "Create the main SundialKit.swift file that uses @_exported to re-export all three modules, making their public APIs available through a single import",
            "dependencies": [
              1
            ],
            "details": "Create Sources/SundialKit/SundialKit.swift with three lines: '@_exported import SundialKitCore', '@_exported import SundialKitNetwork', and '@_exported import SundialKitConnectivity'. This file should contain no additional code - it serves purely as a re-export mechanism. The @_exported attribute ensures all public symbols from the imported modules become available to consumers who import SundialKit.",
            "status": "pending",
            "testStrategy": "Build the target and verify no compilation errors occur with the @_exported imports"
          },
          {
            "id": 3,
            "title": "Write comprehensive tests verifying umbrella import accessibility",
            "description": "Create test suite that validates all public APIs from Core, Network, and Connectivity modules are accessible through the single SundialKit import",
            "dependencies": [
              2
            ],
            "details": "Create Tests/SundialKitTests/SundialKitUmbrellaTests.swift that imports only SundialKit (not the individual modules) and verifies access to key types from each module: NetworkObserver and PathStatus from Network, ConnectivityObserver and ConnectivityMessage from Connectivity, and core protocols from Core. Test should instantiate or reference each major public type to ensure proper symbol visibility. Include platform conditional compilation to handle iOS vs watchOS differences.",
            "status": "pending",
            "testStrategy": "Run 'swift test' to ensure all public APIs are accessible through the umbrella import without needing individual module imports"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement SundialKitCombine compatibility plugin",
        "description": "Create Combine-based plugin package providing v1.0.0 API compatibility with NetworkObserver and ConnectivityObserver",
        "details": "Create SundialKitCombine plugin for backwards compatibility:\n1. NetworkObserver implementation:\n   - Wrap NetworkMonitor from SundialKitCore\n   - @Published properties: pathStatus, isExpensive, isConstrained\n   - Publishers: pathStatusPublisher, isExpensivePublisher, etc.\n   - PassthroughSubject utilities from v1\n   - Implement NetworkStateObserver to bridge changes\n2. ConnectivityObserver implementation:\n   - Wrap ConnectivityManager from SundialKitCore\n   - All v1.0.0 publishers maintained\n   - sendingMessageSubject for message sending\n   - messageReceivedPublisher, replyMessagePublisher\n3. Exact v1.0.0 API surface - no breaking changes\n4. @available guards for platform compatibility\n5. Swift 5.9+ support\n6. Platform: iOS 13+, watchOS 6+, tvOS 13+, macOS 10.15+\n\nCritical: Must pass all v1.0.0 tests unchanged",
        "testStrategy": "Swift Testing migration required. Run entire v1.0.0 test suite against plugin, verify zero API changes needed, test publisher behavior matches v1 exactly.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SundialKitCombine package structure and NetworkObserver wrapper",
            "description": "Set up the SundialKitCombine Swift package with proper directory structure and create the NetworkObserver class that wraps NetworkMonitor from SundialKitCore",
            "dependencies": [],
            "details": "Create Package.swift with SundialKitCombine target, add dependency on SundialKitCore. Create NetworkObserver class with @Published properties for pathStatus, isExpensive, and isConstrained. Initialize with NetworkMonitor instance and set up property observation bridges.",
            "status": "pending",
            "testStrategy": "Test that NetworkObserver initializes correctly, properties are properly published, and NetworkMonitor is correctly wrapped"
          },
          {
            "id": 2,
            "title": "Implement NetworkObserver publishers and PassthroughSubject utilities",
            "description": "Add all v1.0.0 publishers to NetworkObserver including pathStatusPublisher, isExpensivePublisher, isConstrainedPublisher, and port PassthroughSubject extension utilities",
            "dependencies": [
              1
            ],
            "details": "Create Combine publishers for each observable property using @Published projectedValue. Port the PassthroughSubject extension with anyPublisher(for:) helper from v1.0.0. Implement NetworkStateObserver conformance to bridge state changes from NetworkMonitor to Combine publishers.",
            "status": "pending",
            "testStrategy": "Verify all publishers emit correct values when underlying NetworkMonitor state changes, test PassthroughSubject utility methods work as in v1.0.0"
          },
          {
            "id": 3,
            "title": "Create ConnectivityObserver wrapper around ConnectivityManager",
            "description": "Implement ConnectivityObserver class wrapping ConnectivityManager from SundialKitCore with all v1.0.0 @Published properties",
            "dependencies": [
              1
            ],
            "details": "Create ConnectivityObserver with @Published properties: activationState, isReachable, isPaired, isPairedAppInstalled. Initialize with ConnectivityManager instance. Set up property bridges to observe ConnectivityManager state changes and update @Published properties accordingly.",
            "status": "pending",
            "testStrategy": "Test ConnectivityObserver initialization, verify all @Published properties update correctly when ConnectivityManager state changes"
          },
          {
            "id": 4,
            "title": "Implement message publishers and sending subject",
            "description": "Add sendingMessageSubject, messageReceivedPublisher, and replyMessagePublisher to ConnectivityObserver maintaining exact v1.0.0 behavior",
            "dependencies": [
              3
            ],
            "details": "Create sendingMessageSubject as PassthroughSubject<ConnectivityMessage, Never>. Implement messageReceivedPublisher and replyMessagePublisher using PassthroughSubject. Bridge ConnectivityManager's message callbacks to emit on appropriate publishers. Ensure sendingMessageSubject triggers actual message sending through ConnectivityManager.",
            "status": "pending",
            "testStrategy": "Test message sending through sendingMessageSubject, verify messageReceivedPublisher emits on message receipt, test replyMessagePublisher handles reply messages correctly"
          },
          {
            "id": 5,
            "title": "Bridge observer callbacks to Combine publishers",
            "description": "Implement ConnectivityStateObserver and ConnectivityMessageObserver conformance to bridge all callbacks from core to Combine layer",
            "dependencies": [
              2,
              4
            ],
            "details": "Implement observer protocol methods to receive state changes and messages from NetworkMonitor and ConnectivityManager. Convert all callback data to appropriate Combine publisher emissions. Ensure thread safety and proper memory management with weak self captures in closures. Handle platform-specific callbacks appropriately.",
            "status": "pending",
            "testStrategy": "Test all observer callbacks trigger correct publisher emissions, verify no memory leaks or retain cycles, test thread safety under concurrent access"
          },
          {
            "id": 6,
            "title": "Verify complete v1.0.0 API compatibility with existing tests",
            "description": "Run entire v1.0.0 test suite against SundialKitCombine plugin to ensure zero breaking changes and complete API surface coverage",
            "dependencies": [
              5
            ],
            "details": "Import all v1.0.0 tests into SundialKitCombine test target. Update import statements from SundialKit to SundialKitCombine. Run full test suite without any modifications to test code. Document any missing APIs or behavioral differences. Add @available guards for platform compatibility as needed.",
            "status": "pending",
            "testStrategy": "Execute complete v1.0.0 test suite, ensure 100% pass rate with no test modifications required, verify identical behavior between v1.0.0 and plugin implementation"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement SundialKitMessagable compatibility plugin",
        "description": "Create dictionary-based messaging plugin maintaining v1.0.0 Messagable protocol and MessageDecoder",
        "details": "Create SundialKitMessagable plugin for v1.0.0 messaging compatibility:\n1. Port Messagable protocol exactly as in v1.0.0:\n   - static key property for type identification\n   - init?(from:) for decoding\n   - parameters() for encoding\n   - message() helper for ConnectivityMessage conversion\n2. Port MessageDecoder class:\n   - Initialize with array of Messagable.Type\n   - Internal dictionary keyed by Messagable.key\n   - decode(_:) method for type-safe decoding\n3. ConnectivityMessage typealias ([String:Any])\n4. Dictionary serialization utilities\n5. No external dependencies\n6. Swift 5.9+ for compatibility\n7. Platform: iOS 13+, watchOS 6+, tvOS 13+, macOS 10.13+\n\nMust maintain exact v1.0.0 behavior for seamless migration",
        "testStrategy": "Swift Testing required. Test encoding/decoding round trips, MessageDecoder type resolution, property list compliance, backwards compatibility with v1 messages.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Port Messagable protocol with all v1.0.0 methods",
            "description": "Extract and port the Messagable protocol from v1.0.0 codebase with exact API compatibility including static key property, init from dictionary, parameters method, and message helper",
            "dependencies": [],
            "details": "Create Sources/SundialKitMessagable/Messagable.swift with the complete Messagable protocol definition from v1.0.0. Must include: static var key: String for type identification, init?(from: ConnectivityMessage) for decoding from dictionary, func parameters() -> ConnectivityMessage for encoding to dictionary, and extension with func message() -> ConnectivityMessage helper. Ensure Sendable conformance for Swift 6 compatibility. Review v1.0.0 Sources/SundialKit/WatchConnectivity/Messagable.swift for exact implementation details.",
            "status": "pending",
            "testStrategy": "Test protocol conformance with mock types, verify key uniqueness, test init?(from:) with valid and invalid dictionaries, verify parameters() produces valid property list types, test message() helper produces correct format"
          },
          {
            "id": 2,
            "title": "Port MessageDecoder class with type registry",
            "description": "Implement MessageDecoder class that maintains a registry of Messagable types and provides type-safe decoding from ConnectivityMessage dictionaries",
            "dependencies": [
              1
            ],
            "details": "Create Sources/SundialKitMessagable/MessageDecoder.swift with MessageDecoder class from v1.0.0. Initialize with array of Messagable.Type, build internal dictionary keyed by Messagable.key for O(1) lookup. Implement decode(_: ConnectivityMessage) -> Messagable? method that looks up type by key in message and calls appropriate init?(from:). Include thread-safety considerations if needed. Port exact behavior from v1.0.0 Sources/SundialKit/WatchConnectivity/MessageDecoder.swift.",
            "status": "pending",
            "testStrategy": "Test decoder initialization with multiple types, verify type resolution by key, test decoding with valid messages, test handling of unknown keys, test duplicate key handling, verify thread safety if applicable"
          },
          {
            "id": 3,
            "title": "Add ConnectivityMessage typealias and extensions",
            "description": "Define ConnectivityMessage typealias as [String:Any] and add any helper extensions for dictionary serialization utilities",
            "dependencies": [],
            "details": "Create Sources/SundialKitMessagable/ConnectivityMessage.swift with public typealias ConnectivityMessage = [String: Any]. Add any dictionary utility extensions from v1.0.0 for property list validation, safe type casting helpers, or serialization utilities. Ensure all values in ConnectivityMessage conform to property list types (NSString, NSNumber, NSDate, NSData, NSArray, NSDictionary). Document WatchConnectivity compatibility requirements.",
            "status": "pending",
            "testStrategy": "Test typealias is correctly defined, verify property list compliance validation, test any utility extensions for type safety, verify serialization round-trips maintain data integrity"
          },
          {
            "id": 4,
            "title": "Create comprehensive backwards compatibility tests",
            "description": "Implement complete test suite verifying exact v1.0.0 behavior including encoding/decoding round trips and backwards compatibility with existing messages",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create Tests/SundialKitMessagableTests/ with comprehensive test coverage. Include: TestMessage types matching v1.0.0 test fixtures, round-trip encoding/decoding tests, MessageDecoder registry tests with multiple types, property list compliance validation, edge cases (empty messages, nil values, invalid types), performance tests for large message sets. Import actual v1.0.0 test messages if available to verify exact compatibility. Test that migrating from v1.0.0 to plugin requires zero code changes.",
            "status": "pending",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement SundialKitStream modern async plugin",
        "description": "Create actor-based AsyncStream plugin with NetworkStream and ConnectivityStream using Swift 6.1 strict concurrency",
        "details": "Create modern SundialKitStream plugin with Swift 6.1:\n1. actor NetworkStream implementation:\n   - Wrap NetworkMonitor with actor isolation\n   - pathStatusStream: AsyncStream<PathStatus>\n   - isExpensiveStream: AsyncStream<Bool>\n   - isConstrainedStream: AsyncStream<Bool>\n   - async func currentStatus() -> PathStatus\n   - Implement NetworkStateObserver, bridge to AsyncStream\n2. actor ConnectivityStream implementation:\n   - Wrap ConnectivityManager with actor isolation\n   - activationStateStream: AsyncStream<ActivationState>\n   - isReachableStream: AsyncStream<Bool>\n   - messageStream: AsyncStream<ReceivedMessage>\n   - async func send<M>(_ message: M) throws\n   - async func activate() throws(ConnectivityError)\n3. Full Swift 6.1 strict concurrency enabled\n4. No @available guards - declare platforms in Package.swift\n5. Thread-safe by default via actor isolation\n6. No swift-async-algorithms dependency\n\nPlatform: iOS 13+, macOS 10.15+, watchOS 6+, tvOS 13+",
        "testStrategy": "Swift Testing required. Test actor isolation, AsyncStream delivery, concurrent access safety, proper cleanup on stream termination, typed throws behavior.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NetworkStream actor with isolation boundaries",
            "description": "Implement the core NetworkStream actor that wraps NetworkMonitor with proper actor isolation, ensuring thread-safe access to all network state",
            "dependencies": [],
            "details": "Create NetworkStream actor in SundialKitStream target. Define actor NetworkStream with private let networkMonitor: NetworkMonitor. Implement actor isolation boundaries for all state access. Add private continuation storage for AsyncStream management. Implement proper initialization with NetworkMonitor dependency injection. Ensure all public APIs are properly isolated to the actor context.",
            "status": "pending",
            "testStrategy": "Test actor isolation using Task.detached contexts, verify concurrent access safety, test initialization and dependency injection"
          },
          {
            "id": 2,
            "title": "Implement AsyncStream bridges for network properties",
            "description": "Create AsyncStream publishers for pathStatus, isExpensive, and isConstrained properties with proper continuation lifecycle management",
            "dependencies": [
              1
            ],
            "details": "Implement pathStatusStream: AsyncStream<PathStatus> using AsyncStream.makeStream(). Create isExpensiveStream and isConstrainedStream similarly. Implement NetworkStateObserver conformance to receive updates from NetworkMonitor. Bridge observer callbacks to AsyncStream continuations. Handle continuation lifecycle with proper cleanup on stream termination. Implement async func currentStatus() -> PathStatus for synchronous state access.",
            "status": "pending",
            "testStrategy": "Test stream delivery of state changes, verify proper cleanup on cancellation, test multiple concurrent consumers"
          },
          {
            "id": 3,
            "title": "Create ConnectivityStream actor with message handling",
            "description": "Implement the core ConnectivityStream actor that wraps ConnectivityManager with actor isolation for thread-safe WatchConnectivity operations",
            "dependencies": [],
            "details": "Create ConnectivityStream actor in SundialKitStream target. Define actor ConnectivityStream with private let connectivityManager: ConnectivityManager. Implement actor isolation for all connectivity state and message handling. Add private continuation storage for multiple AsyncStream instances. Handle message queue buffering for async delivery. Ensure proper actor context isolation for all public methods.",
            "status": "pending",
            "testStrategy": "Test actor isolation with concurrent operations, verify message queue handling, test initialization with mock ConnectivityManager"
          },
          {
            "id": 4,
            "title": "Implement AsyncStream for connectivity state and messages",
            "description": "Create AsyncStream publishers for connectivity state properties and incoming messages with proper continuation management",
            "dependencies": [
              3
            ],
            "details": "Implement activationStateStream: AsyncStream<ActivationState> using AsyncStream.makeStream(). Create isReachableStream: AsyncStream<Bool> for reachability state. Implement messageStream: AsyncStream<ReceivedMessage> for incoming messages. Create ConnectivityStateObserver conformance to receive updates. Bridge observer callbacks to appropriate stream continuations. Handle multiple consumers and continuation lifecycle properly.",
            "status": "pending",
            "testStrategy": "Test stream delivery timing, verify state synchronization, test message stream buffering and delivery order"
          },
          {
            "id": 5,
            "title": "Add async send and activate methods with typed throws",
            "description": "Implement async methods for sending messages and activating connectivity with Swift 6.1 typed throws for specific error handling",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement async func send<M>(_ message: M) throws(ConnectivityError) where M: Sendable. Convert synchronous ConnectivityManager.send to async with proper error propagation. Implement async func activate() throws(ConnectivityError) for session activation. Use Swift 6.1 typed throws syntax for ConnectivityError. Handle timeout scenarios with withTaskCancellationHandler. Ensure proper actor isolation for all async operations.",
            "status": "pending",
            "testStrategy": "Test typed error throwing, verify timeout handling, test cancellation behavior, test message sending success and failure paths"
          },
          {
            "id": 6,
            "title": "Ensure Swift 6.1 strict concurrency compliance",
            "description": "Verify and enforce full Swift 6.1 strict concurrency mode compliance throughout the plugin with proper Sendable conformance",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Enable strict concurrency checking in Package.swift with swiftLanguageVersions: [.v6_1]. Ensure all types conform to Sendable where appropriate. Fix any concurrency warnings or errors. Verify actor isolation boundaries are properly maintained. Check that all closures and continuations are properly isolated. Remove any @unchecked Sendable usage. Validate no data races are possible.",
            "status": "pending",
            "testStrategy": "Build with strict concurrency enabled, run thread sanitizer tests, verify no runtime concurrency issues"
          },
          {
            "id": 7,
            "title": "Write comprehensive actor isolation and stream tests",
            "description": "Create thorough test suite using Swift Testing to verify actor isolation, stream behavior, and concurrent operation safety",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Write NetworkStreamTests using Swift Testing framework. Test actor isolation with concurrent access patterns. Verify AsyncStream delivery and cleanup behavior. Write ConnectivityStreamTests for message handling and state streams. Test error propagation with typed throws. Verify proper cleanup and resource management. Test stream cancellation and continuation lifecycle. Add performance tests for concurrent operations.",
            "status": "pending",
            "testStrategy": "Use Swift Testing expectations for async tests, verify with thread sanitizer, test resource cleanup with weak references"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement SundialKitBinary serialization plugin",
        "description": "Create format-agnostic binary serialization plugin with BinarySerializable protocol for efficient WatchConnectivity messaging",
        "details": "Create SundialKitBinary plugin for binary messaging:\n1. Define BinarySerializable protocol:\n   - func binaryData() throws -> Data\n   - init(binaryData: Data) throws\n   - Sendable conformance required\n2. WatchConnectivity integration:\n   - Use sendMessageData(_:replyHandler:) when reachable\n   - Fallback to updateApplicationContext with base64 encoding\n   - Message size validation (65KB limit)\n   - Throw ConnectivityError.messageTooBig if exceeded\n3. Type-safe message handling:\n   - Generic send<M: BinarySerializable>(_ message: M) async throws\n   - Generic request<Req, Res>(_ message: Req, expecting: Res.Type, timeout: TimeInterval) async throws -> Res\n   - Automatic serialization/deserialization\n4. Error handling:\n   - SerializationError for encoding/decoding failures\n   - ConnectivityError for delivery failures\n5. Swift 6.1 with strict concurrency\n6. No external dependencies - format agnostic\n\nExample formats: JSON (Codable), Protobuf, MessagePack, CBOR",
        "testStrategy": "Swift Testing required. Test various binary formats, message size validation, sendMessageData integration, fallback mechanisms, error scenarios, round-trip serialization.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define BinarySerializable protocol with Data conversion methods",
            "description": "Create the foundational BinarySerializable protocol with required methods for binary data conversion and Sendable conformance",
            "dependencies": [],
            "details": "Define BinarySerializable protocol in SundialKitBinary module with: func binaryData() throws -> Data for encoding objects to binary, init(binaryData: Data) throws for decoding from binary, and Sendable conformance for Swift 6.1 concurrency. Include SerializationError enum with cases for encoding/decoding failures. Protocol should be format-agnostic to support JSON, Protobuf, MessagePack, CBOR, etc.",
            "status": "pending",
            "testStrategy": "Test protocol conformance with mock implementations, verify Sendable conformance, test error throwing for invalid data"
          },
          {
            "id": 2,
            "title": "Implement WatchConnectivity integration with sendMessageData",
            "description": "Create ConnectivityBinaryManager class that integrates with WatchConnectivity's sendMessageData API for efficient binary messaging",
            "dependencies": [
              1
            ],
            "details": "Implement ConnectivityBinaryManager wrapping ConnectivityManager from SundialKitCore. Add sendBinaryData(_:replyHandler:) method using WCSession.sendMessageData when reachable. Handle reply handlers for two-way binary communication. Bridge BinarySerializable protocol to raw Data for sendMessageData. Maintain thread safety and actor isolation for Swift 6.1 strict concurrency.",
            "status": "pending",
            "testStrategy": "Mock WCSession.sendMessageData calls, verify data passthrough, test reachability checks, test reply handler invocation"
          },
          {
            "id": 3,
            "title": "Add fallback mechanism using base64 encoding for updateApplicationContext",
            "description": "Implement fallback strategy when device is not reachable using updateApplicationContext with base64-encoded binary data",
            "dependencies": [
              2
            ],
            "details": "Add fallback logic in ConnectivityBinaryManager when isReachable is false. Convert binary Data to base64 string for property list compatibility. Wrap in dictionary with metadata (timestamp, type identifier). Use updateApplicationContext for delivery when paired app is installed but not reachable. Handle decoding on receiver side, converting base64 back to Data. Ensure seamless failover between sendMessageData and updateApplicationContext.",
            "status": "pending",
            "testStrategy": "Test base64 encoding/decoding, verify fallback triggers when not reachable, test updateApplicationContext delivery"
          },
          {
            "id": 4,
            "title": "Implement generic send and request methods with type safety",
            "description": "Create type-safe generic methods for sending and requesting binary messages with automatic serialization/deserialization",
            "dependencies": [
              3
            ],
            "details": "Implement generic send<M: BinarySerializable>(_ message: M) async throws method for one-way messaging. Add request<Req: BinarySerializable, Res: BinarySerializable>(_ message: Req, expecting: Res.Type, timeout: TimeInterval) async throws -> Res for request-response patterns. Use Swift concurrency with async/await. Handle automatic serialization to Data and deserialization from Data. Implement timeout handling with Task cancellation. Bridge completion handlers to async/await using CheckedContinuation.",
            "status": "pending",
            "testStrategy": "Test generic type inference, verify serialization round-trips, test timeout scenarios, test cancellation handling"
          },
          {
            "id": 5,
            "title": "Add message size validation and error handling",
            "description": "Implement comprehensive message size validation for WatchConnectivity's 65KB limit and robust error handling",
            "dependencies": [
              4
            ],
            "details": "Add size validation before sending, checking Data.count against 65536 bytes (65KB) limit. Throw ConnectivityError.messageTooBig when exceeded. Implement ConnectivityError enum extending existing errors with binary-specific cases. Add detailed error messages with actual vs maximum size. Consider compression strategies for large messages (document but don't implement). Handle all WatchConnectivity error codes and map to appropriate ConnectivityError cases. Ensure errors propagate correctly through async/await chains.",
            "status": "pending",
            "testStrategy": "Test with messages at size boundaries (64KB, 65KB, 66KB), verify error types and messages, test error propagation"
          },
          {
            "id": 6,
            "title": "Create comprehensive tests for various binary formats and edge cases",
            "description": "Develop extensive test suite covering different binary formats, error scenarios, and integration edge cases",
            "dependencies": [
              5
            ],
            "details": "Create test implementations for JSON (Codable), mock Protobuf, MessagePack simulation, and CBOR-like formats. Test round-trip serialization for each format. Verify size validation with boundary testing. Test concurrent sends and receives. Validate timeout behavior with various durations. Test network state transitions during message sending. Verify fallback mechanism triggers correctly. Test error recovery and retry logic. Include performance tests for serialization overhead. Use Swift Testing framework with @Test attributes.",
            "status": "pending",
            "testStrategy": "Unit tests for each format, integration tests with mock ConnectivitySession, performance benchmarks, concurrent access tests"
          }
        ]
      },
      {
        "id": 9,
        "title": "Migrate all tests to Swift Testing",
        "description": "Convert entire test suite from XCTest to Swift Testing framework across all packages",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "priority": "high",
        "details": "Comprehensive Swift Testing migration:\n1. Core package tests (SundialKitCore, Network, Connectivity):\n   - Replace XCTestCase with @Test functions\n   - Convert XCTAssert* to Swift Testing assertions\n   - Use @Suite for test organization\n   - Parameterized tests for multiple scenarios\n2. Plugin package tests:\n   - SundialKitCombine: Publisher testing with Swift Testing\n   - SundialKitMessagable: Encoding/decoding tests\n3. Testing utilities:\n   - Mock implementations using Swift Testing\n   - Test fixtures and helpers\n   - Async test support\n4. CI/CD updates:\n   - GitHub Actions configuration\n   - Code coverage reporting\n   - Test performance tracking\n5. Documentation:\n   - Testing guide for contributors\n   - Example test patterns\n\nTools: Xcode 16+, Swift 6.1+, swift test command",
        "testStrategy": "Meta-testing: Verify all tests pass, maintain or improve code coverage (target 90%+), ensure CI/CD pipeline works, validate test performance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate SundialKitCore tests to Swift Testing framework",
            "description": "Convert all SundialKitCore test files from XCTest to Swift Testing, including protocol conformance tests and mock implementations",
            "dependencies": [],
            "details": "Replace XCTestCase with @Test functions and @Suite for organization. Convert all XCTAssert statements to Swift Testing assertions (#expect, #require). Update mock implementations to use Swift Testing patterns. Ensure Sendable conformance tests are properly migrated. Update test file imports from XCTest to Testing framework.",
            "status": "pending",
            "testStrategy": "Run migrated tests to ensure all pass, verify code coverage remains at same level or higher, validate that mock implementations work correctly with new framework"
          },
          {
            "id": 2,
            "title": "Migrate NetworkMonitor and PathMonitor tests with mocks",
            "description": "Convert NetworkMonitor tests in SundialKitNetwork from XCTest to Swift Testing, including all mock implementations and observer patterns",
            "dependencies": [
              1
            ],
            "details": "Convert NetworkObserverTests, NWPathMonitorTests, NWInterfaceTests, and PathStatusNetworkTests from XCTest to Swift Testing. Migrate MockPathMonitor and MockNetworkPing to Swift Testing patterns. Convert observer notification tests using @Test with async support. Update thread safety tests to use Swift Testing concurrency features. Convert state change tests to use parameterized testing with @Test(arguments:). Ensure platform-specific behavior tests work on all supported platforms.",
            "status": "pending",
            "testStrategy": "Verify all network state transitions are properly tested, validate mock implementations trigger correct behaviors, ensure concurrent observer tests pass reliably"
          },
          {
            "id": 3,
            "title": "Migrate ConnectivityManager tests with platform scenarios",
            "description": "Convert ConnectivityManager tests in SundialKitConnectivity from XCTest to Swift Testing, handling iOS and watchOS specific behaviors",
            "dependencies": [
              1
            ],
            "details": "Migrate ConnectivityObserver tests (ConnectivityObserverInternalTests, ConnectivityObserverMessageTests, ConnectivityObserverPropertyTests) to Swift Testing. Convert MockConnectivitySession and delegate pattern tests. Update platform-specific tests using @available annotations with Swift Testing. Convert message sending/receiving tests to use async testing patterns. Migrate timeout and fallback mechanism tests. Convert reachability change tests to use parameterized testing for different scenarios.",
            "status": "pending",
            "testStrategy": "Test on both iOS and watchOS simulators, verify platform-specific delegate methods are properly tested, ensure message routing logic is fully covered"
          },
          {
            "id": 4,
            "title": "Convert SundialKitCombine plugin tests to Swift Testing",
            "description": "Migrate all Combine publisher tests from XCTest to Swift Testing, including NetworkObserver and ConnectivityObserver reactive tests",
            "dependencies": [
              2,
              3
            ],
            "details": "Convert PassthroughSubjectTests and publisher testing from XCTest expectations to Swift Testing async/await patterns. Migrate PassthroughSubject tests and anyPublisher(for:) extension tests. Update subscription lifecycle tests using Swift Testing features. Convert publisher value and completion tests to use #expect with async support. Ensure all reactive streams are properly tested.",
            "status": "pending",
            "testStrategy": "Verify all publishers emit expected values, test error propagation through publishers, validate subscription cleanup and memory management"
          },
          {
            "id": 5,
            "title": "Convert SundialKitMessagable plugin tests",
            "description": "Migrate Messagable protocol tests and MessageDecoder tests from XCTest to Swift Testing framework",
            "dependencies": [
              1
            ],
            "details": "Convert MessagableTests, MessageDecoderTests, ConnectivitySendContextTests, and ConnectivityReceiveContextTests from XCTest to Swift Testing. Migrate encoding/decoding tests to use Swift Testing assertions. Update MockMessage implementations to Swift Testing patterns. Convert type registration tests using parameterized testing for multiple message types. Convert ConnectivityMessage dictionary tests. Ensure property list compatibility tests are properly migrated.",
            "status": "pending",
            "testStrategy": "Test encoding/decoding roundtrips for all message types, verify type safety with invalid messages, validate property list compatibility"
          },
          {
            "id": 6,
            "title": "Update CI/CD configuration for Swift Testing",
            "description": "Modify GitHub Actions workflows and scripts to support Swift Testing framework and reporting",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Update GitHub Actions workflow to use swift test with Swift Testing support. Configure code coverage reporting to work with Swift Testing output. Update test result formatting for GitHub Actions annotations. Ensure parallel test execution is properly configured. Add test performance tracking and reporting. Update matrix testing for all supported platforms.",
            "status": "pending",
            "testStrategy": "Verify CI pipeline runs successfully on all platforms, ensure coverage reports are generated correctly, validate test results are properly displayed in GitHub"
          },
          {
            "id": 7,
            "title": "Create testing utilities and migration documentation",
            "description": "Develop Swift Testing utilities, helpers, and comprehensive documentation for contributors",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create common test utilities using Swift Testing patterns (fixtures, helpers, custom assertions). Document Swift Testing best practices and patterns specific to SundialKit. Create migration guide from XCTest to Swift Testing for future contributors. Develop example test patterns for different scenarios (async, actors, publishers). Update README with testing instructions using Swift Testing.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness and accuracy, validate example code compiles and runs, ensure utilities are used consistently across test suite"
          }
        ]
      },
      {
        "id": 10,
        "title": "Create documentation and example applications",
        "description": "Develop comprehensive documentation, migration guides, and example apps demonstrating all v2.0.0 features and migration paths",
        "details": "Documentation and examples:\n1. API Documentation:\n   - DocC documentation for all packages\n   - Inline code documentation\n   - Architecture diagrams\n   - Plugin development guide\n2. Migration Documentation:\n   - MIGRATION.md with step-by-step guide\n   - Compatibility matrix (v1 vs v2)\n   - Common migration patterns\n   - Troubleshooting guide\n3. Example Applications:\n   - V1 compatibility app (Combine + Messagable)\n   - Modern async/await app (Stream)\n   - Binary messaging examples (JSON, custom)\n   - Mixed approach app (Combine + Binary)\n   - iPhone/Watch communication demo\n4. README Updates:\n   - Main README.md with quick start\n   - PLUGINS.md explaining architecture\n   - Update CLAUDE.md for AI assistance\n5. Binary Format Examples:\n   - JSON via Codable\n   - Protobuf integration guide\n   - MessagePack example\n   - Custom binary format\n6. Real-world integration:\n   - Bitness app case study\n   - Performance comparisons\n   - Best practices from production use",
        "testStrategy": "Documentation review, example apps must compile and run correctly, test all code snippets in documentation, validate migration guide with actual v1 project.",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DocC documentation for all public APIs",
            "description": "Generate comprehensive DocC documentation for SundialKitCore, SundialKitNetwork, SundialKitConnectivity, and all plugin packages with inline code documentation and architecture diagrams",
            "dependencies": [],
            "details": "Set up DocC configuration for the entire SundialKit v2.0.0 package. Document all public protocols, classes, structs, and enums with detailed descriptions. Include code examples for each major API. Create architecture diagrams showing the relationship between core packages and plugins. Document the plugin system architecture with clear examples of how to create custom plugins. Ensure all public APIs have proper documentation comments with parameters, return values, and usage examples.",
            "status": "pending",
            "testStrategy": "Verify DocC builds without warnings, all public APIs are documented, code examples compile correctly, and documentation renders properly in Xcode"
          },
          {
            "id": 2,
            "title": "Write MIGRATION.md with step-by-step v1 to v2 guide",
            "description": "Create comprehensive migration guide documenting the transition from SundialKit v1.0.0 to v2.0.0 with compatibility matrix and common patterns",
            "dependencies": [
              1
            ],
            "details": "Create MIGRATION.md file with detailed step-by-step instructions for migrating from v1.0.0 to v2.0.0. Include a compatibility matrix showing v1 vs v2 API differences. Document breaking changes and their solutions. Provide migration patterns for NetworkObserver to NetworkMonitor + plugins, ConnectivityObserver to ConnectivityManager + plugins, and Messagable to BinarySerializable. Include troubleshooting section for common migration issues. Add code snippets showing before/after examples for typical use cases.",
            "status": "pending",
            "testStrategy": "Test migration guide by converting an actual v1 project to v2, verify all code examples compile, validate compatibility matrix accuracy"
          },
          {
            "id": 3,
            "title": "Create v1 compatibility example app using Combine and Messagable plugins",
            "description": "Develop example iOS/watchOS app demonstrating v1 API compatibility using SundialKitCombine and SundialKitMessagable plugins",
            "dependencies": [
              1
            ],
            "details": "Create a fully functional iOS and watchOS example app that uses the v1-compatible API surface through plugins. Implement NetworkObserver using SundialKitCombine plugin showing all Combine publishers. Demonstrate ConnectivityObserver with Messagable protocol for type-safe messaging. Include examples of PathStatus monitoring, network state changes, message sending/receiving, and reachability handling. Show how existing v1 code can work with minimal changes using the compatibility plugins. Include proper error handling and state management patterns.",
            "status": "pending",
            "testStrategy": "Verify app builds and runs on iOS and watchOS, test all network monitoring features, validate message passing between devices, ensure v1 API patterns work correctly"
          },
          {
            "id": 4,
            "title": "Create modern async/await example using Stream plugin",
            "description": "Build example app showcasing modern Swift concurrency with SundialKitStream plugin using async sequences and structured concurrency",
            "dependencies": [
              1
            ],
            "details": "Develop an iOS/watchOS example app using modern Swift concurrency features with SundialKitStream plugin. Implement async sequences for network state monitoring and message streams. Show structured concurrency patterns with Task groups for parallel operations. Demonstrate proper actor isolation for thread-safe state management. Include examples of async/await message sending, AsyncStream-based state observation, and cancellation handling. Show integration with SwiftUI using @MainActor and async view modifiers. Include performance comparisons with Combine approach.",
            "status": "pending",
            "testStrategy": "Test async/await patterns work correctly, verify no data races with Thread Sanitizer, validate cancellation and error handling, ensure SwiftUI integration works smoothly"
          },
          {
            "id": 5,
            "title": "Create binary messaging examples with multiple formats",
            "description": "Develop example implementations demonstrating JSON via Codable, Protobuf, MessagePack, and custom binary format with SundialKitBinary plugin",
            "dependencies": [
              1
            ],
            "details": "Create comprehensive examples showing different binary serialization formats with SundialKitBinary plugin. Implement JSON serialization using Codable with proper error handling. Add Protobuf integration guide with .proto file examples and Swift code generation. Include MessagePack example with size comparisons. Develop custom binary format example showing bit-packing for maximum efficiency. Compare message sizes and performance across all formats. Include proper versioning and backward compatibility strategies. Show fallback handling when messages exceed WatchConnectivity size limits.",
            "status": "pending",
            "testStrategy": "Verify all serialization formats work correctly, test round-trip encoding/decoding, validate size limits are enforced, benchmark performance differences"
          },
          {
            "id": 6,
            "title": "Develop iPhone/Watch communication demo app",
            "description": "Create comprehensive demo app showcasing all WatchConnectivity features including real-time messaging, file transfers, and application context updates",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Build a feature-complete iPhone and Apple Watch demo app showing all aspects of device communication. Implement real-time message passing with reply handlers. Demonstrate file transfer capabilities with progress tracking. Show application context updates for background sync. Include complication data updates and user info transfers. Implement proper reachability handling with automatic fallback strategies. Add debugging UI showing connection state, message history, and performance metrics. Include examples of both v1 compatibility mode and modern v2 patterns side by side.",
            "status": "pending",
            "testStrategy": "Test on actual iPhone and Apple Watch devices, verify all communication methods work, validate fallback mechanisms, ensure complications update correctly"
          },
          {
            "id": 7,
            "title": "Update README and PLUGINS documentation",
            "description": "Revise main README.md with v2.0.0 quick start guide and create comprehensive PLUGINS.md explaining the plugin architecture",
            "dependencies": [
              2
            ],
            "details": "Update README.md with v2.0.0 overview, installation instructions, and quick start examples for common use cases. Create PLUGINS.md with detailed explanation of the plugin architecture, available plugins (Combine, Stream, Binary, Messagable), and guide for creating custom plugins. Update CLAUDE.md with v2.0.0 specific instructions for AI assistance including new package structure and plugin system. Include decision tree helping developers choose between core classes and plugins. Add performance considerations and best practices section. Document platform-specific considerations and minimum deployment targets.",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy and completeness, verify all code snippets compile, test installation instructions on clean project"
          },
          {
            "id": 8,
            "title": "Create real-world integration guide with performance comparisons",
            "description": "Develop comprehensive guide showcasing Bitness app integration as case study with detailed performance benchmarks comparing v1 and v2 approaches",
            "dependencies": [
              6,
              7
            ],
            "details": "Create detailed case study documenting v2.0.0 integration in Bitness app production environment. Include performance benchmarks comparing v1 Combine approach vs v2 plugin-based architecture. Measure memory usage, battery impact, and message latency across different scenarios. Document best practices discovered during production deployment. Show real-world error handling and recovery strategies. Include metrics on binary message size reduction using different formats. Provide decision matrix for choosing between Combine, Stream, or custom observers. Document lessons learned and optimization techniques for high-frequency messaging scenarios.",
            "status": "pending",
            "testStrategy": "Validate performance metrics with actual measurements, verify case study accuracy with production data, test optimization recommendations work as described"
          }
        ]
      },
      {
        "id": 11,
        "title": "Set up multi-repository structure with git subrepo",
        "description": "Create separate repositories for SundialKitCore, SundialKitNetwork, SundialKitConnectivity, and umbrella SundialKit repo with git subrepo integration",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure git-subrepo tooling",
            "description": "Install git-subrepo on development environment and set up basic configuration for multi-repository management",
            "dependencies": [],
            "details": "Install git-subrepo via homebrew (brew install git-subrepo) or from source (https://github.com/ingydotnet/git-subrepo). Verify installation with git subrepo --version. Configure git-subrepo settings in .gitconfig if needed. Test basic commands like git subrepo status and git subrepo help to ensure proper setup. Document installation steps in README for team members.",
            "status": "pending",
            "testStrategy": "Verify git subrepo commands are available, test init/clone/push/pull operations on a test repository, validate .gitsubrepo tracking files are created correctly"
          },
          {
            "id": 2,
            "title": "Create and initialize SundialKitCore repository",
            "description": "Create new GitHub repository for SundialKitCore with shared protocols and types, initialize with proper Swift package structure",
            "dependencies": [
              1
            ],
            "details": "Create new GitHub repo at brightdigit/SundialKitCore. Initialize with Swift package (swift package init --name SundialKitCore). Extract core protocols from existing code: PathMonitor, NetworkPath, NetworkPing, ConnectivitySession, ConnectivitySessionDelegate. Move shared types like PathStatus, ActivationState, SundialError, PassthroughSubject extension. Set up Package.swift with iOS 13+, watchOS 6+, tvOS 13+, macOS 10.13+ platform requirements. Push initial commit.",
            "status": "pending",
            "testStrategy": "Verify Package.swift builds correctly, ensure all protocols compile without dependencies, test import in a sample project"
          },
          {
            "id": 3,
            "title": "Create and populate SundialKitNetwork repository",
            "description": "Create GitHub repository for SundialKitNetwork target containing network monitoring components without Combine dependencies",
            "dependencies": [
              2
            ],
            "details": "Create repo at brightdigit/SundialKitNetwork. Initialize Swift package with dependency on SundialKitCore. Move all files from Sources/SundialKit/Network/ directory. Extract NetworkMonitor class from NetworkObserver (remove Combine). Implement NetworkMonitoring protocol. Maintain PathMonitor abstraction over NWPathMonitor. Support optional NetworkPing integration. Update imports to use SundialKitCore types. Configure Package.swift with proper platform requirements and SundialKitCore dependency.",
            "status": "pending",
            "testStrategy": "Build package independently, verify all Network tests pass when adapted, test integration with SundialKitCore protocols"
          },
          {
            "id": 4,
            "title": "Create and populate SundialKitConnectivity repository",
            "description": "Create GitHub repository for SundialKitConnectivity containing WatchConnectivity components without Combine",
            "dependencies": [
              2
            ],
            "details": "Create repo at brightdigit/SundialKitConnectivity. Initialize Swift package with SundialKitCore dependency. Move all files from Sources/SundialKit/WatchConnectivity/. Extract ConnectivityManager from ConnectivityObserver (remove Combine). Implement ConnectivityManagement protocol. Maintain ConnectivitySession abstraction. Handle platform-specific delegates (iOS vs watchOS). Update imports for SundialKitCore types. Configure Package.swift with iOS/watchOS only platforms.",
            "status": "pending",
            "testStrategy": "Build on iOS and watchOS platforms, adapt existing WatchConnectivity tests, verify message sending/receiving functionality"
          },
          {
            "id": 5,
            "title": "Configure umbrella repository with git subrepo integration",
            "description": "Set up main SundialKit repository as umbrella with git subrepo tracking of Core, Network, and Connectivity modules",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In main SundialKit repo, remove existing Sources/SundialKit contents. Use git subrepo clone for each module: git subrepo clone git@github.com:brightdigit/SundialKitCore.git Sources/SundialKitCore, repeat for Network and Connectivity. Create Sources/SundialKit/SundialKit.swift with @_exported imports of all modules. Update Package.swift to define three targets plus umbrella. Configure .gitsubrepo files for tracking. Test git subrepo pull/push commands. Document workflow in README.",
            "status": "pending",
            "testStrategy": "Verify git subrepo status shows all three subrepos, test pull/push synchronization, validate umbrella import exposes all public APIs, ensure CI builds work with subrepo structure"
          }
        ]
      },
      {
        "id": 12,
        "title": "Remove git subrepos and finalize repository structure",
        "description": "After migration is complete, remove git subrepo tracking from the umbrella repository to transition to standard package dependencies",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove git subrepo configuration and tracking files",
            "description": "Remove all git subrepo configuration files, tracking metadata, and related git configurations from the umbrella repository",
            "dependencies": [],
            "details": "Remove .gitrepo files for SundialKitCore, SundialKitNetwork, and SundialKitConnectivity subrepos. Remove git subrepo configuration from git config. Clean up any subrepo-specific git hooks or metadata files that were created during the subrepo setup process.",
            "status": "pending",
            "testStrategy": "Verify no .gitrepo files remain, confirm git config has no subrepo entries, ensure git status shows clean working directory"
          },
          {
            "id": 2,
            "title": "Update Package.swift to use standard package dependencies",
            "description": "Replace subrepo path dependencies with proper Swift Package Manager dependencies pointing to the separate repositories",
            "dependencies": [
              1
            ],
            "details": "Modify Package.swift to replace local path dependencies for SundialKitCore, SundialKitNetwork, and SundialKitConnectivity with proper package dependencies using .package(url:, from:) syntax. Update target dependencies to reference the external packages. Ensure version constraints are properly specified for each dependency.",
            "status": "pending",
            "testStrategy": "Swift build succeeds with external dependencies, swift package resolve works correctly, Package.resolved reflects external repositories"
          },
          {
            "id": 3,
            "title": "Remove local source directories for subrepo packages",
            "description": "Remove the local Sources subdirectories that were managed by git subrepo for the core packages",
            "dependencies": [
              2
            ],
            "details": "Remove Sources/SundialKitCore, Sources/SundialKitNetwork, and Sources/SundialKitConnectivity directories from the umbrella repository since these are now managed as separate repositories. Update .gitignore to ensure these directories are not accidentally re-added. Clean up any build artifacts or derived data related to these local sources.",
            "status": "pending",
            "testStrategy": "Verify directories are removed, build still succeeds with external dependencies, git status shows clean working directory"
          },
          {
            "id": 4,
            "title": "Update CI/CD workflows and scripts",
            "description": "Modify GitHub Actions workflows and build scripts to handle standard package dependencies instead of subrepo management",
            "dependencies": [
              3
            ],
            "details": "Update .github/workflows files to remove git subrepo commands and replace with standard swift package manager commands. Modify Scripts/build.sh and other build scripts to remove subrepo-specific logic. Update CI to use swift package resolve instead of git subrepo pull. Remove any subrepo-specific environment variables or configurations from CI.",
            "status": "pending",
            "testStrategy": "CI builds pass with external dependencies, all GitHub Actions workflows execute successfully, build scripts work without subrepo commands"
          },
          {
            "id": 5,
            "title": "Update documentation and README for standard package structure",
            "description": "Update project documentation to reflect the transition from subrepos to standard Swift Package Manager dependencies",
            "dependencies": [
              4
            ],
            "details": "Update README.md to remove references to git subrepo commands and replace with standard SPM usage. Modify CLAUDE.md to remove subrepo-related development instructions. Update any developer documentation that referenced the subrepo structure. Add instructions for contributing to the separate repositories. Update package dependency examples in documentation.",
            "status": "pending",
            "testStrategy": "Documentation accurately reflects new structure, all code examples work with external dependencies, contribution guidelines are clear"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-12T15:38:46.462Z",
      "updated": "2025-10-12T16:01:04.849Z",
      "description": "Tasks for master context"
    }
  }
}